<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="jp">
<head>
<title>
リバーシプログラムの作り方
</title>
</head>
<body background="../img/bg.gif" bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#0000ff" alink="#9900ff">
<a href="../index.html">＜目次＞</a>
<a href="6_5.html">＜前へ＞</a>
<a href="6_7.html">＜次へ＞</a>
<table width="600" border="0" cellpadding="3">
<tr bgcolor="#333399">
<td>
<font size=+1 color="#ffffff">
<b>6.6 定石の探索</b>
</font>
</td>
</tr>
</table>
<p>
本節では、対局時に登録済みの定石を使用する方法について説明します。<br>
この処理はComクラスで行ないます。<br>
</p>
<ul>
<li><b>関数定義</b>
<p>
最初にComクラスの生成関数の定義を修正します。<br>
ComクラスがOpeningクラスを使用できるようにします。<br>
</p>
<p>
<b>Com *Com_New(Evaluator *evaluator, Opening *opening)</b><br>
</p>
<p>
Openingクラスへのポインタopeningを追加してあります。<br>
</p>
<p>
次に定石に関係する関数を追加します。<br>
</p>
<p>
<b>void	Com_SetOpening(Com *self, int in_use)</b>
</p>
<p>
定石を使用するかどうかを設定します。<br>
引数<br>
&nbsp;self : Comクラスへのポインタ<br>
&nbsp;in_use : 0なら定石使用、1なら定石を使用しない<br>
戻り値 なし<br>
</p>
<p>
<pre>
</pre>
</p>
<li><b>Com構造体の修正</b>
<p>
Comクラスで定石を扱えるようにするために、Com構造体にメンバ変数を追加します。<br>
追加する変数は２個です。<br>
</p>
<p>
<pre>
struct _Com
{
	Board *Board;
	Evaluator *Evaluator;
<font color="red">	/* Openingクラスへのポインタを追加 */
	Opening *Opening;
	/* 定石を使用するかどうかのフラグを追加 */
	int UseOpening;</font>
	int MidDepth;
	int WLDDepth;
	int ExactDepth;
	int Node;
	MoveList Moves[BOARD_SIZE * BOARD_SIZE];
};
</pre>
</p>
<li><b>Comクラスの生成</b>
<p>
Com構造体にメンバ変数を追加したので、生成関数も修正します。<br>
生成時にそれぞれに変数を初期化するようにします。<br>
</p>
<p>
<pre>
<font color="red">static int Com_Initialize(Com *self, Evaluator *evaluator, Opening *opening)</font>
{
	memset(self, 0, sizeof(Com));
	self->Board = Board_New();
	if (!self->Board) {
		return 0;
	}
	self->Evaluator = evaluator;
	if (!self->Evaluator) {
		return 0;
	}
<font color="red">	self->Opening = opening;
	if (!self->Opening) {
		return 0;
	}
	/* 初期化時には定石を使用しないようにする */
	self->UseOpening = 0;</font>
	self->MidDepth = 1;
	self->WLDDepth = 1;
	self->ExactDepth = 1;
	self->Node = 0;
	return 1;
}

<font color="red">Com *Com_New(Evaluator *evaluator, Opening *opening)</font>
{
	Com *self;
	self = malloc(sizeof(Com));
	if (self) {
<font color="red">		if (!Com_Initialize(self, evaluator, opening)) {</font>
			Com_Delete(self);
			self = NULL;
		}
	}
	return self;
}
</pre>
</p>
<li><b>定石の設定</b>
<p>
新たに関数を追加したのでその実装を行ないます。<br>
Com_SetOpening()は以下のようになっています。<br>
メンバ変数UseOpeningに指定された値を代入しているだけです。<br>
</p>
<p>
<pre>
void Com_SetOpening(Com *self, int in_use)
{
	self->UseOpening = in_use;
}
</pre>
</p>
<li><b>定石データの探索</b>
<p>
コンピュータ思考時に、次の手を定石の中から選ばせるように修正します。<br>
まずCom_NextMove()は以下のようになります。<br>
</p>
<p>
<pre>
int Com_NextMove(Com *self, const Board *in_board, int in_color, int *out_value)
{
	int result;
	int left;
	int value;
	int color;

	Board_Copy(in_board, self->Board);
	self->Node = 0;
	left = Board_CountDisks(self->Board, EMPTY);
	Com_MakeList(self);
	Board_InitializePattern(self->Board);
<font color="red">	value = Com_OpeningSearch(self, in_color, Board_OpponentColor(in_color), &amp;result);
	if (result != NOMOVE) {
	} else </font>if (left <= self->ExactDepth) {
		value = Com_EndSearch(self, left, -BOARD_SIZE * BOARD_SIZE, BOARD_SIZE * BOARD_SIZE, in_color, Board_OpponentColor(in_color), 0, &amp;result);
		value *= DISK_VALUE;
	} else if (left <= self->WLDDepth) {
		value = Com_EndSearch(self, left, -BOARD_SIZE * BOARD_SIZE, 1, in_color, Board_OpponentColor(in_color), 0, &amp;result);
		value *= DISK_VALUE;
	} else {
		if ((in_color == WHITE &amp;&amp; self->MidDepth % 2 == 0) ||
			(in_color == BLACK &amp;&amp; self->MidDepth % 2 == 1)) {
			Board_Reverse(self->Board);
			color = Board_OpponentColor(in_color);
		} else {
			color = in_color;
		}
		value = Com_MidSearch(self, self->MidDepth, -MAX_VALUE, MAX_VALUE, color, Board_OpponentColor(color), 0, &amp;result);
	}
	if (out_value) {
		*out_value = value;
	}

	return result;
}
</pre>
</p>
<p>
最初にCom_OpeningSearch()を呼び出すようにしました。<br>
Com_OpeningSearch()は定石データから手を選び出す関数です。<br>
実装は以下のようになっています。<br>
</p>
<p>
<pre>
static int Com_OpeningSearch(Com *self, int in_color, int in_opponent, int *out_move)
{
	MoveList *p;
	PositionInfo info;
	int value, max = -MAX_VALUE;
	int count = 0;

	*out_move = NOMOVE;
	if (!self->UseOpening || !self->Opening) {
		return max;
	}
	for (p = self->Moves->Next; p; p = p->Next) {
		if (Board_Flip(self->Board, in_color, p->Pos)) {
			if (Opening_Info(self->Opening, self->Board, in_opponent, &amp;info)) {
				value = -info.Value;
				if (value > max) {
					*out_move = p->Pos;
					max = value;
					count = 1;
				} else if (value == max) {
					count++;
					if (get_rand(count) < 1) {
						*out_move = p->Pos;
					}
				}
			}
			Board_Unflip(self->Board);
		}
	}
	return max;
}
</pre>
</p>
<p>
引数は以下の通りです。<br>
self : Comクラスへのポインタ<br>
in_color : 自分の手番<br>
in_opponent : 相手の手番<br>
out_move : 次の手を格納するためのint変数へのポインタ<br>
定石データから手を選択できた場合にはout_moveに選択した手を格納してその手の評価値を返します。<br>
手を選択できなかった場合にはout_moveにNOMOVEを格納します。<br>
</p>
<p>
処理内容ですが、１手読みを行なって評価値が最大となる手を選択します。<br>
ただし局面の評価値は定石データから取得しています。<br>
また評価値が最大となる手が複数存在した場合にはランダムに手を選ぶようにしています。<br>
</p>
<p>
乱数を生成するマクロget_rand()は以下の通りです。<br>
0〜(in_max-1)までの整数をランダムに返します。<br>
</p>
<p>
<pre>
#define get_rand(in_max) ((int)((double)(in_max) * rand() / (RAND_MAX + 1.0)))
</pre>
</p>
</ul>
<a href="../index.html">＜目次＞</a>
<a href="6_5.html">＜前へ＞</a>
<a href="6_7.html">＜次へ＞</a>
<hr>
&copy;2006 Daiki Sanno, All Rights Reserved<br>
<a href="mailto:support@es-cube.net">mailto:support@es-cube.net</a><br>
</body>
</html>
