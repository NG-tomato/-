<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="jp">
<head>
<title>
リバーシプログラムの作り方
</title>
</head>
<body background="../img/bg.gif" bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#0000ff" alink="#9900ff">
<a href="../index.html">＜目次＞</a>
<a href="4_5.html">＜前へ＞</a>
<a href="5_1.html">＜次へ＞</a>
<table width="600" border="0" cellpadding="3">
<tr bgcolor="#333399">
<td>
<font size=+1 color="#ffffff">
<b>4.6 評価パラメータ更新の改善</b>
</font>
</td>
</tr>
</table>
<p>
いままでのプログラムでは１手毎にパラメータの更新を行なっていました。<br>
しかしこれだと特定のパターンだけ多く更新されてしまいます。<br>
一手進めただけでは、局面のパターン構成が大きく変わらないためです。<br>
特定のパターンだけパラメータ更新を行なうと、パラメータが安定しません。<br>
</p>
<p>
そこで、もっとゆっくりパラメータ更新を行なうようにします。<br>
具体的には以下のようにします。<br>
<ul>
<li>１手毎に出現した局面と評価値の差分を登録する<br>
評価値の差分とは（（目標とする局面の評価値）−（Evaluatorによる局面の評価値））のことです。<br>
<li>一定の対局回数毎にパラメータ更新を行なう
<li>出現回数が一定以上のパターンだけ更新する
</ul>
</p>
<ul>
<li><b>関数の追加と修正</b>
<p>
まず"evaluator.h"の修正を行ないます。<br>
局面を登録する関数Evaluator_Addを追加します。<br>
同時にパラメータ更新関数Evaluator_Updateの引数を修正します。<br>
</p>
<p>
<pre>
<font color="red">/* 局面登録関数の追加 */
void		Evaluator_Add(Evaluator *self, const Board *in_board, int in_value);
/* パラメータ更新関数の修正 */
void		Evaluator_Update(Evaluator *self);</font>
</pre>
</p>
<p>
関数仕様は以下の通りです。
</p>
<li><b>定数の修正</b>
<p>
これ以降は"evaluator.c"の修正です。<br>
まず定数の修正を行ないます。<br>
評価パラメータ更新の度合いUPDATOE_RATIOを0.005に上げます。<br>
それから評価値更新に必要な出現数MIN_FREQUENCYを定義します。<br>
MIN_FREQUENCY回以上出現していないパターンは更新を行ないません。<br>
これによって急激な更新が行なわれることを避けます。<br>
</p>
<p>
<pre>
/* 評価パラメータ更新の度合い */
<font color="red">#define UPDATE_RATIO 0.005</font>

/* パターンの最大評価値 */
#define MAX_PATTERN_VALUE (DISK_VALUE * 20)

<font color="red">/* 評価値更新に必要な出現数 */
#define MIN_FREQUENCY 10</font>
</pre>
</p>
<li><b>構造体の修正</b>
<p>
PatternNumは「あるパターンが何回出現したか」を格納しておく変数です。<br>
PatternSumには評価値の差分の合計を格納します。<br>
</p>
<p>
<pre>
struct _Evaluator
{
	int *Value[PATTERN_ID_NUM];
<font color="red">	/* パターンの修験回数 */
	int *PatternNum[PATTERN_ID_NUM];
	/* 評価値差分の合計 */
	double *PatternSum[PATTERN_ID_NUM];</font>
	int MirrorLine[POW_3_8];
	int MirrorCorner[POW_3_8];
};
</pre>
</p>
<p>
</p>
<li><b>クラスの初期化と破棄</b>
<p>
構造体の修正を行なったので、Evaluatorクラスの初期化時と終了時の処理も修正します。<br>
初期化時にはPattern_NumとPatternSumの領域を確保します。<br>
終了時には確保した領域を解放します。<br>
</p>
<p>
<pre>
static int Evaluator_Initialize(Evaluator *self)
{
	int i, j;
	int mirror_in, mirror_out, coeff;
	int mirror_corner_coeff[] = { POW_3_2, POW_3_5, POW_3_0, POW_3_3, POW_3_6, POW_3_1, POW_3_4, POW_3_7 };

	memset(self, 0, sizeof(Evaluator));
	for (i = 0; i < PATTERN_ID_NUM; i++) {
		self->Value[i] = calloc(PatternSize[i], sizeof(int));
		if (!self->Value[i]) {
			return 0;
		}
<font color="red">		/* 追加したメンバ変数の初期化 */
		self->PatternNum[i] = calloc(PatternSize[i], sizeof(int));
		if (!self->PatternNum[i]) {
			return 0;
		}
		self->PatternSum[i] = calloc(PatternSize[i], sizeof(double));
		if (!self->PatternSum[i]) {
			return 0;
		}</font>
	}
	（中略）

	return 1;
}

static void Evaluator_Finalize(Evaluator *self)
{
	int i;
	for (i = 0; i < PATTERN_ID_NUM; i++) {
<font color="red">		/* 追加したメンバ変数の領域解放 */
		if (self->PatternSum[i]) {
			free(self->PatternSum[i]);
		}
		if (self->PatternNum[i]) {
			free(self->PatternNum[i]);
		}</font>
		if (self->Value[i]) {
			free(self->Value[i]);
		}
	}
}
</pre>
</p>
<li><b>局面登録</b>
<p>
追加した局面登録関数Evaluator_Add()の実装を行ないます。<br>
処理の内容以下の通りです。<br>
</p>
<p>
<ul>
<li>評価値の差分（（与えられた局面評価値）−（Evaluatorによる局面評価値））を計算する
<li>局面からパターンの抽出を行なう
<li>抽出した各パターンの出現回数PatternNumを１増やし、評価値差分をPatternSumに加える
</ul>
</p>
<p>
対称なパターンが存在する場合には、対称なパターンのPatternNum、PatternSumも操作します。<br>
Evaluator_Add()は長いので一部省略します。<br>
</p>
<p>
<pre>
static void Evaluator_AddPattern(Evaluator *self, int in_pattern, int in_id, int in_mirror, double in_diff)
{
	self->PatternNum[in_pattern][in_id]++;
	self->PatternSum[in_pattern][in_id] += in_diff;
	if (in_mirror >= 0) {
		self->PatternNum[in_pattern][in_mirror] = self->PatternNum[in_pattern][in_id];
		self->PatternSum[in_pattern][in_mirror] = self->PatternSum[in_pattern][in_id];
	}
}

void Evaluator_Add(Evaluator *self, const Board *in_board, int in_value)
{
	int index;
	double diff;

	diff = (double)(in_value - Evaluator_Value(self, in_board));
	index = BOARD_INDEX_8(in_board, A4, B4, C4, D4, E4, F4, G4, H4);
	Evaluator_AddPattern(self, PATTERN_ID_LINE4, self->MirrorLine[index], index, diff);
	index = BOARD_INDEX_8(in_board, A5, B5, C5, D5, E5, F5, G5, H5);
	Evaluator_AddPattern(self, PATTERN_ID_LINE4, self->MirrorLine[index], index, diff);
	index = BOARD_INDEX_8(in_board, D1, D2, D3, D4, D5, D6, D7, D8);
	Evaluator_AddPattern(self, PATTERN_ID_LINE4, self->MirrorLine[index], index, diff);
	index = BOARD_INDEX_8(in_board, E1, E2, E3, E4, E5, E6, E7, E8);
	Evaluator_AddPattern(self, PATTERN_ID_LINE4, self->MirrorLine[index], index, diff);
	index = BOARD_INDEX_8(in_board, A3, B3, C3, D3, E3, F3, G3, H3);

	（中略）

	index = BOARD_INDEX_8(in_board, A1, B1, C1, A2, B2, C2, A3, B3);
	Evaluator_AddPattern(self, PATTERN_ID_CORNER8, self->MirrorCorner[index], index, diff);
	index = BOARD_INDEX_8(in_board, H1, G1, F1, H2, G2, F2, H3, G3);
	Evaluator_AddPattern(self, PATTERN_ID_CORNER8, self->MirrorCorner[index], index, diff);
	index = BOARD_INDEX_8(in_board, A8, B8, C8, A7, B7, C7, A6, B6);
	Evaluator_AddPattern(self, PATTERN_ID_CORNER8, self->MirrorCorner[index], index, diff);
	index = BOARD_INDEX_8(in_board, H8, G8, F8, H7, G7, F7, H6, G6);
	Evaluator_AddPattern(self, PATTERN_ID_CORNER8, self->MirrorCorner[index], index, diff);
	Evaluator_AddPattern(self, PATTERN_ID_PARITY, Board_CountDisks(in_board, EMPTY) &amp; 1, -1, diff);
}
</pre>
</p>
<li><b>パラメータ更新</b>
<p>
最後にパラメータ更新関数Evaluator_Update()を修正します。<br>
出現回数が一定以上のパターンに対して以下の式で評価値更新を行なうようにします。<br>
</p>
<p>
（更新後の評価値）＝（更新前の評価値）＋（評価値差分の合計）／（出現回数）×（更新の度合い）
</p>
<p>
<pre>
static void Evaluator_UpdatePattern(Evaluator *self, int in_pattern, int in_id)
{
	int diff;

	if (self->PatternNum[in_pattern][in_id] > MIN_FREQUENCY) {
		diff = (int)(self->PatternSum[in_pattern][in_id] / self->PatternNum[in_pattern][in_id] * UPDATE_RATIO);
		if (MAX_PATTERN_VALUE - diff < self->Value[in_pattern][in_id]) {
			self->Value[in_pattern][in_id] = MAX_PATTERN_VALUE;
		} else if (-MAX_PATTERN_VALUE - diff > self->Value[in_pattern][in_id]) {
			self->Value[in_pattern][in_id] = -MAX_PATTERN_VALUE;
		} else {
			self->Value[in_pattern][in_id] += diff;
		}
		self->PatternNum[in_pattern][in_id] = 0;
		self->PatternSum[in_pattern][in_id] = 0;
	}
}

void Evaluator_Update(Evaluator *self)
{
	int i, j;

	for (i = 0; i < PATTERN_ID_NUM; i++) {
		for (j = 0; j < PatternSize[i]; j++) {
			Evaluator_UpdatePattern(self, i, j);
		}
	}
}
</pre>
</p>
<li><b>学習</b>
<p>
最後に"main.c"の学習処理learn()を修正します。<br>
上記の修正に伴い、１手毎にEvaluator_Add()を呼び、一定対局毎にEvaluator_Update()を呼び出します。<br>
</p>
<p>
<pre>
static void learn(Board *board, Evaluator *evaluator, Com *com)
{
	char buffer[BUFFER_SIZE];
	int history_color[BOARD_SIZE * BOARD_SIZE];
	int i, j, move, num, turn, value;
	int color;
	int result;

	printf("対戦回数を入力してください\n");
	get_stream(buffer, BUFFER_SIZE, stdin);
	num = atoi(buffer);

	Com_SetLevel(com, 4, 12, 12);
	for (i = 0; i < num; i++) {

		（中略）

		for (j = Board_CountDisks(board, EMPTY); j < BOARD_SIZE * BOARD_SIZE - 12; j++) {
			turn--;
			Board_Unflip(board);
			if (history_color[turn] == BLACK) {
<font color="red">				/* 局面の登録 */
				Evaluator_Add(evaluator, board, result);</font>
			} else {
				Board_Reverse(board);
<font color="red">				/* 局面の登録 */
				Evaluator_Add(evaluator, board, -result);</font>
				Board_Reverse(board);
			}
		}
<font color="red">		/* パラメータ更新 */
		if ((i + 1) % 10 == 0) {
			Evaluator_Update(evaluator);
		}</font>
		if ((i + 1) % 100 == 0) {
			printf("学習中... %d / %d\r", i + 1 , num );
			Evaluator_Save(evaluator, EVALUATOR_FILE);
		}
	}
	Evaluator_Save(evaluator, EVALUATOR_FILE);
	printf("終了しました");
}
</pre>
</p>
<p>
では実際に学習を行なってみましょう。<br>
といいたいところですが、次章で評価関数の高速化を行ないます。<br>
実際に学習を行なうのはそれが終わってからにしましょう。<br>
</p>
</ul>
<a href="../index.html">＜目次＞</a>
<a href="4_5.html">＜前へ＞</a>
<a href="5_1.html">＜次へ＞</a>
<hr>
&copy;2006 Daiki Sanno, All Rights Reserved<br>
<a href="mailto:support@es-cube.net">mailto:support@es-cube.net</a><br>
</body>
</html>
